
这个也是面试的常考点


四点要素

    状态 State
        灵感，创造力，存储小规模问题的结果
    方程 Function
        状态之间的联系，怎么通过小的状态，来算大的状态
    初始化 Intialization
        最极限的小状态是什么, 起点
    答案 Answer
        最大的那个状态是什么，终点


常见四种类型

    Matrix DP (10%) - 矩阵
    Sequence (40%) - 序列
    Two Sequences DP (40%) - 双序列
    Backpack (10%) - 背包

    注意点

        贪心算法大多题目靠背答案，所以如果能用动态规划就尽量用动规，不用贪心算法


特别复杂的时候考虑一下双重循环


## 基于matrix:

Solution120: 根据题意，直接使用动态规划即可, 基于matrix

Solution62：难点在于初始状态的构造，其余按照动态规划套路即可

Solution63: 在题62的情况下多加一个判断

## 基于Sequence:

Solution70: 还是初始态度的构建

Solution55: **贪心算法**，难点在于问题的转化以及临界状态的判定。其实还是靠背答案吧

Solution45: 难点在于问题的转化，贪心算法。其实还是靠背答案吧

Solution300: 难点还是找出规律，双重迭代。

背包问题

常见的0-1背包和完全背包的核心区别在于循环哪个在外，因为对于0-1背包而言，每个物品
只能用一次，因此，物品栏在外.

部分背包问题：所有物品是可再分的，即允许将某件物品的一部分（例如 1/3）放入背包；

0-1 背包问题：所有物品不可再分，要么整个装入背包，要么放弃，不允许出现“仅选择物品的 1/3 装入背包”的情况；

完全背包问题：不对每一件物品的数量做限制，同一件物品可以选择多个装入背包；

多重背包问题：每件物品的数量是有严格规定的，比如物品 A 有 2 件，物品 B 有 3 件。

- 0-1 背包

这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。

这就是 0-1 背包这个名词的来历。

```text
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。
其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，
最多能装的价值是多少？
```


- 0-1背包变种
```text
LSolution92: 背包问题：不可重复

LSolution125：背包问题2，多了一个价值
```
- 背包问题的变种
  
Solution416： 难点在于问题的转化


- 完全背包


https://blog.csdn.net/ccc369639963/article/details/122578376

Solution139: **零钱问题**，双重迭代，经典的dp问题

Solution1143: 画表格，然后第一行第一列为空。

Solution322: **零钱问题**，可重复

LSolution92: 背包问题：不可重复

LSolution125：背包问题2，多了一个价值